# -*- coding: utf-8 -*-
"""git-mod hw4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iq3QXBg37V2JvFk2-aaSHfTxZZOK4FyE

In this assignment, we will use Gurobi to solve a DC optimal power flow (OPF) problem while determining the locational marginal prices (LMPs) simultaneously, for the [modified PJM 5-bus system](https://doi.org/10.1109/PES.2010.5589973).
"""

from IPython.display import Image
Image('case5.png', width=600)

"""The DC OPF problem is formulated as a linear programming problem:
$$
\begin{align*}
\min_{\boldsymbol{p}} \qquad & \boldsymbol{c}^T\boldsymbol{p} \\
\text{s.t.} \qquad & \boldsymbol{1}^T\boldsymbol{d} = \boldsymbol{1}^T\boldsymbol{p}, & & :\lambda \\
& \boldsymbol{S}'(\boldsymbol{W}'\boldsymbol{p} - \boldsymbol{d}') \le \boldsymbol{f}^{\max}, & & :\boldsymbol{\mu} \\
& -\boldsymbol{S}'(\boldsymbol{W}'\boldsymbol{p} - \boldsymbol{d}') \le \boldsymbol{f}^{\max}, & & :\boldsymbol{\nu} \\
& \boldsymbol{p}^{\min} \le \boldsymbol{p} \le \boldsymbol{p}^{\max}.
\end{align*}
$$
In this formulation, the only decision variables are the generation outputs $\boldsymbol{p}$. The generating limits are
$$
\boldsymbol{p}^{\min} = (0, 0, 0, 0, 0)^T, \quad \boldsymbol{p}^{\max} = (40, 170, 520, 200, 600)^T.
$$
The marginal costs are
$$
\boldsymbol{c} = (14, 15, 30, 40, 10)^T.
$$
The bus loads are
$$
\boldsymbol{d} = (0, 300, 300, 400, 0)^T.
$$
The line reactances are
$$
(x_{AB}, x_{AD}, x_{AE}, x_{BC}, x_{CD}, x_{DE})^T = (0.0281, 0.0304, 0.0064, 0.0108, 0.0297, 0.0297)^T.
$$
The line flow limits are
$$
\boldsymbol{f}^{\max} = (400, \infty, \infty, \infty, \infty, 240)^T.
$$
Let bus D be the slack bus. The bus net injections except the slack bus are
$$
\boldsymbol{W}'\boldsymbol{p} - \boldsymbol{d}',
$$
where $\boldsymbol{W}'$ is obtained by removing the row corresponding to the slack bus from the generator-bus incidence matrix $\boldsymbol{W}$:
$$
\boldsymbol{W} =
\begin{bmatrix}
1 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 1
\end{bmatrix},
$$
and $\boldsymbol{d}'$ is obtained from $\boldsymbol{d}$ by removing the element corresponding to the slack bus. The matrix of power transfer distribution factors or generation shift factors, $\boldsymbol{S}'$, maps $\boldsymbol{W}'\boldsymbol{p} - \boldsymbol{d}'$ to the line flows. It can be shown that
$$
\boldsymbol{S}' = \boldsymbol{H}\boldsymbol{A}'(\boldsymbol{B}')^{-1},
$$
where $\boldsymbol{H}$ is a diagonal matrix of the reciprocals of the line reactances:
$$
\boldsymbol{H} = \operatorname{diag}\left(\frac{1}{x_{AB}}, \frac{1}{x_{AD}}, \frac{1}{x_{AE}}, \frac{1}{x_{BC}}, \frac{1}{x_{CD}}, \frac{1}{x_{DE}}\right),
$$
$\boldsymbol{A}'$ is obtained by removing the column corresponding to the slack bus from the bus-line incidence matrix $\boldsymbol{A}$:
$$
\boldsymbol{A} =
\begin{bmatrix}
1 & -1 & 0 & 0 & 0 \\
1 & 0 & 0 & -1 & 0 \\
1 & 0 & 0 & 0 & -1 \\
0 & 1 & -1 & 0 & 0 \\
0 & 0 & 1 & -1 & 0 \\
0 & 0 & 0 & 1 & -1
\end{bmatrix},
$$
and
$$
\boldsymbol{B}' = (\boldsymbol{A}')^T\boldsymbol{H}\boldsymbol{A}'.
$$
Moreover, define $\boldsymbol{S}$ as obtained by adding a zero column corresponding to the slack bus from $\boldsymbol{S}'$.

Once the problem is solved, the LMPs $\boldsymbol{\pi}$ can be calculated based on the dual optimal solution $(\lambda^*, \boldsymbol{\mu}^*, \boldsymbol{\nu}^*)$:
$$
\boldsymbol{\pi} = \underbrace{\lambda^*\boldsymbol{1}}_{\text{energy component}} + \underbrace{\boldsymbol{S}^T(\boldsymbol{\nu}^* - \boldsymbol{\mu}^*)}_{\text{congestion component}}.
$$
Note that we have not considered losses in the formulation; in practice, there is another loss component in the LMP.

Now formulate and solve the problem in Gurobi. The skeleton has been provided. you need to output the results in Table 7, Table 8, and Table 9 in the aforementioned paper. Also, to align with the Gurobi API, you need to express the problem in the following form:
$$
\begin{align*}
\min_{\boldsymbol{p}} \qquad & \boldsymbol{c}^T\boldsymbol{p} \\
\text{s.t.} \qquad & \boldsymbol{1}^T\boldsymbol{d} = \boldsymbol{1}^T\boldsymbol{p}, & & :\lambda \\
& -\boldsymbol{S}'\boldsymbol{W}'\boldsymbol{p} \ge -\boldsymbol{S}'\boldsymbol{d}' - \boldsymbol{f}^{\max}, & & :\boldsymbol{\mu} \\
& \boldsymbol{S}'\boldsymbol{W}'\boldsymbol{p} \ge \boldsymbol{S}'\boldsymbol{d}' - \boldsymbol{f}^{\max}, & & :\boldsymbol{\nu} \\
& \boldsymbol{p}^{\min} \le \boldsymbol{p} \le \boldsymbol{p}^{\max}.
\end{align*}
$$
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install gurobipy

import numpy as np
import gurobipy as gp
from gurobipy import GRB

# set p_min, p_max, mc, f_max, W_prime, d_prime, H, A_prime, B_prime, S_prime, S
p_min = np.array([0,0,0,0,0]).transpose()
p_max = np.array([40,170,520,200,600]).transpose()
mc = np.array([14,15,30,40,10]).transpose()
f_max = np.array([400, GRB.INFINITY, GRB.INFINITY, GRB.INFINITY, GRB.INFINITY, 240]).transpose()

W = np.array([ [1,1,0,0,0], [0,0,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1] ])
# W_prime =  np.array([ [1,1,0,0,0], [0,0,0,0,0], [0,0,1,0,0], [0,0,0,0,1]])
# dropping the fourth row to find the prime W_prime
W_prime = np.delete(W, 3, 0)
d = np.array([0,300,300,400,0]).transpose()
d_prime = np.array([0,300,300,0]).transpose()

LR = np.array([0.0281,0.0304,0.0064,0.0108,0.0297,0.0297])
LR_reciprocal = np.reciprocal(LR)
H = np.diag(LR_reciprocal)

A = np.array([ [1,-1,0,0,0], [1,0,0,-1,0], [1,0,0,0,-1], [0,1,-1,0,0], [0,0,1,-1,0], [0,0,0,1,-1]])
# A_prime = np.array([ [1,-1,0,0], [1,0,0,0], [1,0,0,-1], [0,1,-1,0], [0,0,1,0], [0,0,0,-1]])
# dropping the fourth column to find the prime A_prime
A_prime = np.delete(A, 3, 1)

B_prime = A_prime.transpose() @ H @ A_prime
S_prime = H @ A_prime @ np.linalg.inv(B_prime)

# ğ‘† is obtained by adding zero column corresponding to the slack bus(4th column) from ğ‘†â€²
S = np.insert(S_prime, 3, np.zeros(6), axis=1)

# checking dimensions of all matrices 
print(H.shape)
print(A_prime.shape)
print(B_prime.shape)
print(S_prime.shape)
print(W_prime.shape)
print((S_prime @ W_prime).shape)
print((S_prime @ W_prime @ d).shape)

m = gp.Model()
m.Params.LogToConsole = 0
p = m.addMVar(5, lb=p_min, ub=p_max, obj=mc, name='p')
m.modelSense = GRB.MINIMIZE
m.setObjective( mc.transpose() @ p )
c_lambda = m.addConstr(np.ones(5).transpose() @ d == np.ones(5).transpose() @ p)
c_mu = m.addConstr( -S_prime @ W_prime @ p >= -S_prime @ d_prime - f_max )
c_nu = m.addConstr( S_prime @ W_prime @ p >= S_prime @ d_prime - f_max )
m.optimize()

# print optimal dispatch p 
if (m.status == GRB.OPTIMAL):
    for var in m.getVars():
        print(var.varName, var.x)

# print optimal value of the objective function
print(m.objVal)

# print the LMP energy component 
p =  m.getAttr('x', m.getVars())
print(c_lambda.pi * np.ones(5))

# print the LMP congestion components 
print(S.transpose() @ (c_nu.pi - c_mu.pi))

# print the LMPs 
# pi = energy component + congestion components
print(c_lambda.pi * np.ones(5) + S.transpose() @ (c_nu.pi - c_mu.pi))

# print the line flows 
# from ğ‘†â€²(ğ‘Šâ€²ğ‘âˆ’ğ‘‘â€²)â‰¤ğ‘“max 
print(S_prime @ (W_prime @ p - d_prime))